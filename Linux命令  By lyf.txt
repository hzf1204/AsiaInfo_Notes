
*************************************** 		VIM  		  *************************************
一切光标前后的基准都以光标所圈的字符的左边为基准!!!!
vim 模式下命令的使用
vim下面共有三种模式
(1)   一般模式  输入:进入命令模式,按ESC返回一般模式  (2)  一般模式下键盘键入  i在光标前插入  I在行首插入  a在光标后插入  A在行末插入

命令模式下 :set nu每一行就有行号了   :set nonu取消行号

一般模式下  j下k上h左l右    o 在当前行下一行插入新的空行 O 在当前行的上一行插入新的空行  
	H当前屏幕最顶行  L 屏幕最末行 M屏幕中间行  /word 从光标处向后查找与word字符串匹配的项 ?word从光标处向前查找
	x光标后删除一个字符  X光标前删除一个字符  dd删除光标所在的那一行
	y复制当前行与下一行   yy复制所在行  nyy复制光标所在起的向下n行（注意 当前行为第一行为基准 ）  
        p粘贴到当前行的下一行 P粘贴到当前行的上一行    u 撤回操作 ctr+r前进操作   pageup  pagedown 翻页
输入模式下  home行首  end行尾 
gg光标移动至文本的首行   GG光标切换至最后一行

**************************************   	常用指令         ****************************************************
<<<<<<< HEAD
0 标准输入  1 标准输出  2 错误输出  标准输入输出的地方都默认是屏幕     eg: cat  123 456 1>log.txt          (假设当前目录下有123文件 却没有456文件  则这条命令就把标准输出1 的内容输出到了log.txt文件中,而错误输出输出了屏幕上)
						也可以分开将标准输出重定向到不同的地方   cat test.txt  123 1>suc.log  2>fal.log
>  输出重定向   覆盖!
>>  输出重定向  追加

<输入重定向
<

=======
>>>>>>> origin/master
关闭防火墙systemctl stop firewalld.service    禁止防火墙开机自动启动 systemctl disable firewalld.service

rpm -qa  显示已经安装了的软件

yum list   查看可以安装的软件列表 

yum install   软件名字       安装某个软件

find . -type f -executable    在当前目录下查找可执行的文件

  `内容`    可以使` `中的命令的输出作为另一个命令的输入参数  例如:cat `find ./ -name "shell*" -print` 
  |管道符

在terminal下按shift+pageup/pageon 可以上下翻页

mkdir   -p  输入-p  可以创建不存在的父文件夹

mv old地址+文件名 new地址   移动或者重命名

date  获取时间
例如:date +%Y-%m-%d-%H-%M-%S  输出为 2017-08-16-02-49-50  2017年8月16日2点49分50秒
%m  月份(0-12)    %M 分钟(0-59) %S 秒（0-59）%d 每个月的第几天(1-31)

cp复制  -r可以递归复制目录 cp ~~   . 第二个参数输入 . 拷到当前目录下  也可指定目录  例如第二个参数输入 /复制到根目录下

rm  删除   -rf可以递归删除目录  -f强制删除

pwd  查看当前在哪个目录

su 获取root 权限   exit退出root权限

userdel lyf    删除用户   输入 -r  /删除用户同时，其“家目录”地址也会被删除

env 查看所有环境变量

more,less  这是两个显示一般文本文件的指令。如果一个文本文件太长了超过一个屏幕的画面，用cat来看实在是不理想，就可以试试more和less两个指令。More指令可以使超过一页的文件临时停留在屏幕，等你按任何的一个键以后，才继续显示。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，所以你随意浏览，阅读文章时，less是个非常好的选择

ln Cs 源文件 目标文件  -s 软连接 没输入则是硬链接

cat -n 文件名   查看文件(带行号)


# tar -cf all.tar *.jpg  -c是表示产生新的包，-f指定包的文件名
# tar -rf all.tar *.gif  -r是表示增加文件的意思。
# tar -tf all.tar    列出all.tar包中所有文件，-t是列出文件的意思
 tar -xf all.tar    //解包至当前目录了   -x是解开的意思
 tar调用gzip
gzip是一个压缩程序  .gz 结尾与gzip相对的解压程序是gunzip  tar中使用-z调用gzip
tar调用bzip2 bzip2是一个压缩能力更强的压缩程序，  .bz2结尾 bzip2压缩的结果  tar中使用-j这个参数来调用bzip2 
tar调用compress  compress也是一个压缩程序  .Z结尾的文件  -Z  调用compress
1)对于.tar结尾的文件   tar -xf all.tar
2)对于.gz结尾的文件 gzip -d all.gz   gunzip all.gz
3)对于.tgz或.tar.gz结尾的文件  tar -xzf all.tar.gz 
4)对于.bz2结尾的文件 bzip2 -d all.bz2 bunzip2 all.bz2
5)对于tar.bz2结尾的文件  tar -xjf all.tar.bz2
6)对于.Z结尾的文件  uncompress all.Z
7)对于.tar.Z结尾的文件  tar -xZf all.tar.z

which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。  例如 which java   which javac

find
find / -name "*.txt" -print 用于查找所有的‘ *.txt’文件在当前目录及子目录中； 
find / -name "[A-Z]*" -print 用于根目录查找文件名以一个大写字母开头的文件；    .是当前目录  ..是上级目录
find / -name "[a-z][a-z][0--9][0--9].txt" -print 在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是.txt的文件； 
-name  按照文件名查找文件
-user  按照文件属主来查找文件。
-group 按照文件所属的组来查找文件。 
-type  查找某一类型的文件，诸如： 　b - 块设备文件。 　d - 目录。 　c - 字符设备文件。 　p - 管道文件。 　l - 符号链接文件。 　f - 普通文件

whereis
whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。
和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。

ftp
输入ftp命令进入ftp模式  如果linux ftp命令没反应可能是没装ftp客户端  需要安装  yum -y install ftp
简单示例
ftp
open 210.35.205.39
wcp
123456
然后就进入了ftp目录
使用cd ls 查看在ftp下的目录中活动与查看
！+命令 可以将命令传给shell
lcd在本机目录中活动
binary  二进制传输模式   相对的还有ascii
get 文件名   下载文件至本机当年目录下   get是获取一个文件的命令
mget 文件名  可以获取一个文件夹的内容
put mput 类似
close 关闭ftp流

tail -n 10 -f  显示10行 使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容.  
实例：从第5行开始显示文件
tail -n +5 log2014.log

head 显示文件的头信息  head -n 9 文件名   显示这个文件的前9行

touch  创建文件或修改已存在文件的修改时间

nl 文件名   输出文件(带行号) 有点类似于 cat -n 文件名

chmod
- rw- r-- r--
表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只	有读权限；其他用户也只有读权限。
确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。 

du查看文件大小
du -m  -k  -a +文件名

hostname   查看当前主机名

hostname  newname  更改主机名为newname   ----临时修改主机名  reboot后就失效了

nmtui   弹出的界面中修改主机名    永久生效





###linux 配置jdk
如果想要  环境变量永久生效  可以修改下面两个文件中的任何一个：
1 /etc/profile    全局的  针对所有用户生效的
2  ~/.bash_profile    仅对当前用户生效的
例如以下 为配置 jdk的方式
export JAVA_HOME="/usr/jdk1.8"
export PATH="$PATH:$JAVA_HOME/bin"
export JRE_HOME="$JAVA_HOME/jre"
export CLASSPATH=".:$JAVA_HOME/lib:$JAVA_HOME/lib"

修改ip配置文件 的文件所处的位置:   /etc/sysconfig/networkd-scripts/

***********************************    	  Linux根目录结构 	  ****************************************************
 Linux系统目录结构
    /bin ― 用来贮存用户命令。目录 /usr/bin 也被用来贮存用户 命令。  
 /sbin ― 许多系统命令（例如 shutdown）的贮存位置。 
目录 /usr/sbin 中也包括了许多系统命令。   
/root ― 根用户（超级用户）的主目录。   
/mnt ― 该目录中通常包括系统引导后被挂载的文件系统的挂 载点。譬如，默认的光盘挂载点是 
/mnt/cdrom/.   
/boot ― 包括内核和其它系统启动期间使用的文件。   
/lost+found ― 被 fsck 用来放置零散文件（没有名称的文件）。  
/lib ― 包含许多被 /bin/ 和 /sbin/ 中的程序使用的库文件。  
/usr/lib/ 中含有更多用于用户程序的库文件。   
/dev ― 贮存设备文件（注意，设备文件不是驱动程序。过去， 在添加新磁盘或设备后，往往需要手动增加设备文件。现在通常我们不需要手动增加设备文件，运行一下service kudzu start ，系统就会自动配置相应的设备）。   
/etc ― 包含许多系统配置文件和目录。   
/var ― 用于贮存variable（或不断改变的）文件，例如日志文 件和打印机假脱机文件。   
/usr ― 包括与系统用户直接有关的文件和目录，  例如应用程序及支持它们的库文件。   
/proc ― 一个虚拟的文件系统（不是实际贮存在磁盘上的），  它包括被某些程序使用的系统信息。   
/etc/rc.d ― 启动的配置文件和脚本。 
/tmp/ ― 用户和程序的临时目录。所有系统用户均可读写。  
/home ― 用户主目录的默认位置。   
/opt ―  可选的（optional），可用来存放准备安装的文件。







一般模式下删除、复制粘贴
x,X
x为向后删除一个字符，X为向前删除一个字符
nx（n为数字）
向后删除n个字符
dd
删除光标所在的那一行
ndd（n为数字）
删除光标所在的向下n行
d1G
删除光标所在行到第一行的所有数据
dG
删除光标所在行到末行的所有数据
yy
复制光标所在的那行
nyy
复制从光标所在行起向下n行
p,P
p复制的数据从光标下一行粘贴，P则从光标上一行粘贴
y1G
复制光标所在行到第一行的所有数据
yG
复制光标所在行到末行的所有数据
J
讲光标所在行与下一行的数据结合成同一行
u
还原过去的操作







#### #################################################################### ssh 口令远程登录##################################

ssh root@192.168.85.2    -p  222       以root身份登录85.2主机  SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口   
1.第一次登录远程主机的时候 会有如下提示:

The authenticity of host '192.168.85.3 (192.168.85.3)' can't be established.
ECDSA key fingerprint is a6:dc:fe:45:43:a6:63:2b:94:f4:b3:f1:de:1b:f5:f9.
Are you sure you want to continue connecting (yes/no)?  

这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？
所谓"公钥指纹"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。
很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。

2.假定经过风险衡量以后，用户决定接受这个远程主机的公钥。
Are you sure you want to continue connecting (yes/no)? yes 

3.系统会出现一句提示，表示host主机已经得到认可。
Warning: Permanently added '192.168.85.3' (ECDSA) to the list of known hosts.

4.接下来会提示你输入远程主机的用户密码:
root@192.168.85.3's password:       -----输入之后就顺利登录了远程主机

当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。
每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。

###  ssh 公钥登录

使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。
所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。
远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

1这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：
ssh-keygen -t rsa        ---期间提示什么可以都不用输入  直接回车跳过

运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。
2这时再输入下面的命令，将公钥传送到远程主机host上面：
ssh-copy-id user@host          -----  会提示你输入远程主机用户的密码  然后 会自动把你客户端的公钥追加到 远程主机的~/.ssh/authorized_keys文件末尾   然后你以后登录就不需要输入密码了



authorized_keys文件
远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。















